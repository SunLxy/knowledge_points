(self.webpackChunkknowledge_points=self.webpackChunkknowledge_points||[]).push([["src_pages_9_docker_index_md"],{30978:function(n,e,a){"use strict";a.r(e),a.d(e,{default:function(){return t}});var t={components:{},data:{},source:"\n# Docker\n\n## 新建 Dockerfile\n\n```bash\ncd docker-demo && touch Dockerfile\n```\n\n## 准备 Nginx 镜像\n\n```bash\ndocker pull nginx \n```\n\n控制台会出现如下信息：\n\n```bash\nUsing default tag: latest\nlatest: Pulling from library/nginx\n8559a31e96f4: Pull complete\n8d69e59170f7: Pull complete\n3f9f1ec1d262: Pull complete\nd1f5ff4f210d: Pull complete\n1e22bfa8652e: Pull complete\nDigest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133\nStatus: Downloaded newer image for nginx:latest\ndocker.io/library/nginx:latest\n```\n\n在项目根目录创建nginx配置文件\n\n```bash\ntouch default.conf  \n```\n\n写入：\n\n```nginx\nserver {\n    listen       80;\n    server_name  localhost;\n    #charset koi8-r;\n    access_log  /var/log/nginx/host.access.log  main;\n    error_log  /var/log/nginx/error.log  error;\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\n```\n\n## 配置镜像\n\n打开 Dockerfile ，写入如下内容：\n\n```dockerfile\nFROM nginx\nCOPY dist/ /usr/share/nginx/html/\nCOPY default.conf /etc/nginx/conf.d/default.conf\n```\n\n* FROM nginx 指定该镜像是基于 nginx:latest 镜像而构建的。\n* COPY dist/ /usr/share/nginx/html/ 命令的意思是将项目根目录下 dist 文件夹中的所有文件复制到镜像中 /usr/share/nginx/html/ 目录下。\n* COPY default.conf /etc/nginx/conf.d/default.conf 将 default.conf 复制到 etc/nginx/conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置。\n\n## 构建镜像\n\nDocker 通过 build 命令来构建镜像：\n\n```bash\ndocker build -t docker-demo .\n```\n\n* -t 参数给镜像命名 docker-demo。\n* . 是基于当前目录的 Dockerfile 来构建镜像。\n\n执行成功后，将会输出：\n\n```bash\nSending build context to Docker daemon  115.4MB\nStep 1/3 : FROM nginx\n ---> 2622e6cca7eb\nStep 2/3 : COPY dist/ /usr/share/nginx/html/\n ---> Using cache\n ---> 82b31f98dce6\nStep 3/3 : COPY default.conf /etc/nginx/conf.d/default.conf\n ---> 7df6efaf9592\nSuccessfully built 7df6efaf9592\nSuccessfully tagged docker-demo:latest\n\n```\n\n镜像制作成功！我们来查看一下容器：\n\n```bash\ndocker image ls | grep docker-demo\n```\n\n可以看到，我们打出了一个 133MB 的项目镜像：\n\n```bash\ndocker-demo latest 7df6efaf9592 About a minute ago 133MB\n```\n\n## 运行容器\n\n```bash\ndocker run -d -p 3000:80 --name docker-demo docker-demo\n```\n\n* -d 设置容器在后台运行。\n* -p 表示端口映射，把本机的 3000 端口映射到 container 的 80 端口（这样外网就能通过本机的 3000 端口访问了。\n* --name 设置容器名 docker-demo\n* docker-demo 是我们上面构建的镜像名字。\n\n## 更新\n\n1. 停止并删除当前容器\n\n``` bash\ndocker stop 7df6efaf9592 && docker rmi -f 7df6efaf9592\n```\n\n1. 重新创建容器\n\n```bash\ndocker build -t docker-demo .\n```\n\n1. 运行和端口映射\n\n```bash\ndocker run -d -p 3000:80 --name docker-demo docker-demo\n```\n\n## docker 命令\n\n```bash\n1. docker start [OPTIONS] CONTAINER [CONTAINER...]  启动一个或多个已经被停止的容器\n2. docker stop [OPTIONS] CONTAINER [CONTAINER...] 停止一个运行中的容器\n3. docker restart [OPTIONS] CONTAINER [CONTAINER...]  重启容器\n```\n\n## 常规操作\n\n①参数使用\n\nFROM：\n\n```bash\n   # 指定基础镜像，所有构建的镜像都必须有一个基础镜像，且 FROM 命令必须是 Dockerfile 的第一个命令\n   # FROM <image> [AS <name>] 指定从一个镜像构建起一个新的镜像名字\n   # FROM <image>[:<tag>] [AS <name>] 指定镜像的版本 Tag\n   # 示例：FROM mysql:5.0 AS database\n```\n\nMAINTAINER：\n\n```bash\n   # 镜像维护人的信息\n   # MAINTAINER <name>\n   # 示例：MAINTAINER Jartto Jartto@qq.com\n```\n\nRUN：\n\n```bash\n# 构建镜像时要执行的命令\n# RUN <command>\n# 示例：RUN [executable, param1, param2]\n```\n\nADD：\n\n```bash\n   # 将本地的文件添加复制到容器中去，压缩包会解压，可以访问网络上的文件，会自动下载\n   # ADD <src> <dest>\n   # 示例：ADD *.js /app 添加 js 文件到容器中的 app 目录下\n```\n\nCOPY：\n\n```bash\n   # 功能和 ADD 一样，只是复制，不会解压或者下载文件\n```\n\nCMD：\n\n```bash\n   # 启动容器后执行的命令，和 RUN 不一样，RUN 是在构建镜像是要运行的命令\n   # 当使用 docker run 运行容器的时候，这个可以在命令行被覆盖\n   # 示例：CMD [executable, param1, param2]\n```\n\nENTRYPOINT：\n\n```bash\n   # 也是执行命令，和 CMD 一样，只是这个命令不会被命令行覆盖\n   # ENTRYPOINT [executable, param1, param2]\n   # 示例：ENTRYPOINT [donnet, myapp.dll]\n```\n\nLABEL：为镜像添加元数据，key-value 形式\n\n```bash\n   # LABEL <key>=<value> <key>=<value> ...\n   # 示例：LABEL version=1.0 description=这是一个web应用\n```\n\nENV：设置环境变量，有些容器运行时会需要某些环境变量\n\n```bash\n   # ENV <key> <value> 一次设置一个环境变量\n   # ENV <key>=<value> <key>=<value> <key>=<value> 设置多个环境变量\n   # 示例：ENV JAVA_HOME /usr/java1.8/\n```\n\nEXPOSE：暴露对外的端口（容器内部程序的端口，虽然会和宿主机的一样，但是其实是两个端口）\n\n```bash\n   # EXPOSE <port>\n   # 示例：EXPOSE 80\n   # 容器运行时，需要用 -p 映射外部端口才能访问到容器内的端口\n```\n\nVOLUME：指定数据持久化的目录，官方语言叫做挂载\n\n```bash\n   # VOLUME /var/log 指定容器中需要被挂载的目录，会把这个目录映射到宿主机的一个随机目录上，实现数据的持久化和同步\n   # VOLUME [/var/log,/var/test.....] 指定容器中多个需要被挂载的目录，会把这些目录映射到宿主机的多个随机目录上，实现数据的持久化和同步\n   # VOLUME /var/data var/log 指定容器中的 var/log 目录挂载到宿主机上的 /var/data 目录，这种形式可以手动指定宿主机上的目录   * \n```\n\nWORKDIR：设置工作目录，设置之后 ，RUN、CMD、COPY、ADD 的工作目录都会同步变更\n\n```bash\n  # WORKDIR <path>\n  # 示例：WORKDIR /app/test\n```\n\nUSER：指定运行命令时所使用的用户，为了安全和权限起见，根据要执行的命令选择不同用户\n\n```bash\n   # USER <user>:[<group>]\n   # 示例：USER test\n```\n\nARG：设置构建镜像是要传递的参数\n\n```bash\n   # ARG <name>[=<value>]\n   # ARG name=sss\n```\n\n更多操作，请移步官方使用文档[3]：\nhttps://docs.docker.com/\n\n引用原文：\nhttps://segmentfault.com/a/1190000038280613",headings:[{key:0,value:"Docker",depth:1,children:[{key:1,value:"新建 Dockerfile",depth:2},{key:3,value:"准备 Nginx 镜像",depth:2},{key:11,value:"配置镜像",depth:2},{key:15,value:"构建镜像",depth:2},{key:25,value:"运行容器",depth:2},{key:28,value:"更新",depth:2},{key:35,value:"docker 命令",depth:2},{key:37,value:"常规操作",depth:2}]}],headingsList:[{key:0,value:"Docker",depth:1},{key:1,value:"新建 Dockerfile",depth:2},{key:3,value:"准备 Nginx 镜像",depth:2},{key:11,value:"配置镜像",depth:2},{key:15,value:"构建镜像",depth:2},{key:25,value:"运行容器",depth:2},{key:28,value:"更新",depth:2},{key:35,value:"docker 命令",depth:2},{key:37,value:"常规操作",depth:2}]}}}]);